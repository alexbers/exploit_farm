#!/usr/bin/env python
# author: Alexander Bersenev (Bay) from Hackerdom team
# posts flags from flags/*.txt to submit server

import re
import socket
import random

from glob import glob
from time import time, sleep, strftime

from flag_format import FLAG_FORMAT

FLAGS_IN_SUMBIT_ITERATION = 100
FLAGS_GLOB                = "flags/*.txt"
HOST                      = '127.0.0.1'  # checksystem hostaddr here
PORT                      = 31337        # checksystem port here
TIMEOUT                   = 5            # checksystem timeout
RESTART_DELAY             = 2            # in sec


def log(text):
    print(strftime("%H:%M:%S ") + text)

class PostedFlags:
    GOOD_FLAGS_FILE = "posted_good_flags.txt"
    BAD_FLAGS_FILE  = "posted_bad_flags.txt"

    def __init__(self):
        # create flags files if not exists
        open(PostedFlags.GOOD_FLAGS_FILE, 'ab').close()
        open(PostedFlags.BAD_FLAGS_FILE,  'ab').close()

        good_flags_content = open(PostedFlags.GOOD_FLAGS_FILE, "rb", 1).read()
        good_flags         = re.findall(FLAG_FORMAT, good_flags_content)
        self.good_flags    = set(good_flags)

        bad_flags_content  = open(PostedFlags.BAD_FLAGS_FILE, "rb", 1).read()
        bad_flags          = re.findall(FLAG_FORMAT, bad_flags_content)
        self.bad_flags     = set(bad_flags)

    def add_good_flag(self, flag):
        if flag not in self.good_flags:
            with open(PostedFlags.GOOD_FLAGS_FILE, "ab") as f:
                f.write(flag + b"\n")
            self.good_flags.add(flag)

    def add_bad_flag(self, flag):
        if flag not in self.bad_flags:
            with open(PostedFlags.BAD_FLAGS_FILE, "ab") as f:
                f.write(flag + b"\n")
            self.bad_flags.add(flag)

    def get(self):
        return self.good_flags | self.bad_flags


###################################################
def submit_flags(flags, posted_flags):
    "YOU LIKELY HAVE TO EDIT THIS FUNCTION"

    # STAGE 0: connecting
    s = socket.create_connection((HOST, PORT), TIMEOUT)

    # just an example how to use sockets over SSL
    # import ssl
    # s = ssl.wrap_socket(s,
    #                     keyfile="team_private_key.pem",
    #                     certfile="team_cert.pem",
    #                     server_side=False, cert_reqs=False,
    #                     ssl_version=ssl.PROTOCOL_SSLv3,
    #                     do_handshake_on_connect=1
    #                    )

    # # STAGE 1: check if system greets us
    # greeting = s.recv(4096)
    # if b'Hello' not in greeting:
    # 	print("Not greeted: " + greeting)
    # 	return
    #
    # # STAGE 2: send the team name
    # s.sendall(b"hackerdom\n")
    #
    # # STAGE 3: check if system asks for a password
    # pass_greeting = s.recv(4096)
    # if b'pass' not in pass_greeting:
    # 	print("Not pass-greeted: %s" % pass_greeting)
    # 	return
    #
    # # STAGE 4: send the password
    # s.sendall(b"pass\n")
    #
    # # STAGE 5: check if system asks for flags
    # keys_prompt = s.recv(4096)
    # if b'keys' not in keys_prompt:
    # 	print("Not keys prompted %s" % keys_prompt)
    # 	return

    for flag in flags:
        # STAGE 6: send a flag
        s.sendall(flag + b"\n")

        # STAGE 7: check result
        result = s.recv(4096).strip().lower()

        # GOOD ANSWERS
        if      (b'accepted' in result or
                 b'congratulations' in result):
            posted_flags.add_good_flag(flag)
        # BAD ANSWERS
        elif    (b'bad' in result or
                 b'wrong' in result or
                 b'expired' in result or
                 b'unknown' in result or
                 b'your own' in result or
                 b'not in database' in result or
                 b'already submitted' in result):
            posted_flags.add_bad_flag(flag)
        # NEUTRAL ANSWERS
        elif    (b'timeout' in result or
                 b'game not started' in result or
                 b'game over' in result):
            pass
        else:
            print("unknown answer: %s" % result)
##################################################


def get_all_flags():
    flags = list()
    flag_files = glob(FLAGS_GLOB)     # all files with flags

    for flag_file in flag_files:
        file_contents   = open(flag_file, "rb" , 1).read()
        flags          += re.findall(FLAG_FORMAT, file_contents)

    return flags

# main posting cycle
while True:
    begin_load_time = time()
    posted_flags    = PostedFlags()
    flags           = list(set(get_all_flags()) - posted_flags.get()) # get new flags

    if len(flags) > FLAGS_IN_SUMBIT_ITERATION:
        flags       = random.sample(flags, FLAGS_IN_SUMBIT_ITERATION)

    end_load_time   = time()

    log("Loaded %s new flags in %.2f sec, sending %s random" %
        (len(flags_set), end_load_time - begin_load_time, len(flags)))

    good_before = len(posted_flags.good_flags)
    bad_before  = len(posted_flags.bad_flags)

    if flags:
        try:
            submit_flags(flags, posted_flags)
        except Exception as E:
            log("Exception while submitting: %s" % E + "\a")

    good_after = len(posted_flags.good_flags)
    bad_after  = len(posted_flags.bad_flags)

    log("Iteration finished: good %s, bad %s" %
        (good_after - good_before, bad_after - bad_before))
    sleep(RESTART_DELAY)
