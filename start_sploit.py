#!/usr/bin/env python
# author: Alexander Bersenev (Bay) from Hackerdom team
# starts one sploit for all teams

from flag_format import FLAG_FORMAT
from team_list   import TEAMS

from time        import sleep, strftime
from os.path     import basename, splitext, abspath, exists
from subprocess  import Popen, PIPE, STDOUT
import threading
import re
import sys
import os

TIMEOUT = 60  # sploit timeout in sec


def log(text):
    print("%s " % strftime("%H:%M:%S") + text)


def get_unfinished_teams():
    return [t.name for t in threading.enumerate() if t.daemon]


class TeamOwner(threading.Thread):
    def __init__(self, sploit_name, team_name, team_ip):
        threading.Thread.__init__(self, name=team_name)

        self.sploit_name = sploit_name
        self.team_name   = team_name
        self.team_ip     = team_ip

        spl_short_name = splitext(basename(sploit_name))[0]
        log_filename   = "flags_%s_%s.txt" % (spl_short_name, team_name)
        self.logfile   = open(log_filename, "ab", 0)

        self.existed_flags = set()

    def run(self):
        log("Lauching %s %s for %s" %
              (basename(self.sploit_name), self.team_ip, self.team_name))
        try:
            need_launch_in_shell = (os.name == "nt")
            # launch sploit proccess with team_ip as arg
            spl = Popen([self.sploit_name, self.team_ip],
                        stdout=PIPE, stderr=STDOUT,
                        shell=need_launch_in_shell, bufsize=1)
            # get output by lines until EOF
            while True:
                nextline = spl.stdout.readline()
                if not nextline:
                    break

                nextline = nextline.strip()
                if not nextline:
                    continue
                print("%s: %s" % (self.team_name, nextline))

                flags = re.findall(FLAG_FORMAT, nextline)
                for flag in flags:
                    log("Flag from %s: %s" % (self.team_name, flag))
                    if flag not in self.existed_flags:
                        self.logfile.write(flag + b"\n")
                        self.existed_flags.add(flag)
            spl.communicate()  # wait for finish
        except Exception as E:
            log("Exception, team %s: %s" % (self.team_name, E) + "\a")

# LETS ROCK !!!
if len(sys.argv) < 2:
    print("Usage: start_sploit.py <sploit>")
    sys.exit(1)

sploit_name = abspath(sys.argv[1])
if not exists(sploit_name):
    print("Sploit doesn't exist: " + sploit_name)
    sys.exit(1)

for team_name, team_ip in TEAMS.items():
    owner = TeamOwner(sploit_name, team_name, team_ip)
    owner.daemon = True
    owner.start()  # start pwning thread for the team

# do small 1-sec sleeps till ctrl-c or till end of the work
try:
    for i in range(TIMEOUT):
        sleep(1)
        if not get_unfinished_teams():
            break

except KeyboardInterrupt:
    print("Ctrl-c received!")

if get_unfinished_teams():
    log("Done. Teams with timeouts: %s" % get_unfinished_teams())
else:
    log("Done.")
