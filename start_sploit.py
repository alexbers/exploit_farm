#!/usr/bin/env python3
# author: Alexander Bersenev (Bay) from Hackerdom team
# starts one sploit for all teams in a loop

import re
import sys
import os
import multiprocessing
import threading
import queue

from os.path     import basename, splitext, abspath, exists
from subprocess  import Popen, PIPE, STDOUT
from time        import time, sleep, strftime

from flag_format import FLAG_FORMAT
from team_list import *

MAX_RUNTIME = 2  # in secs, sploit will be restarted if it running too long
PAUSE = 10  # in secs, the time between sploit relaunches

def log(text):
    print(strftime("%H:%M:%S ") + text)

class TeamOwner():
    def __init__(self, sploit_name, team_name, team_ip):

        self.sploit_name = sploit_name
        self.team_name   = team_name
        self.team_ip     = team_ip

        # The name of the exploit file without an extension
        spl_short_name     = splitext(basename(sploit_name))[0]
        self.flag_filename = "flags/%s_%s.txt" % (spl_short_name, team_name)

        open(self.flag_filename, 'ab').close()  # create file if not exists

        savedflags = re.findall(FLAG_FORMAT,
                                         open(self.flag_filename, "rb").read())
        self.flags = set(savedflags) # to avoid duplication

        self.cycle_num = 0

        log("Starting hacking team %s, launching in a loop: %s %s" %
              (self.team_name, basename(self.sploit_name), self.team_ip))

# !!!!!!!!!  1) It prints the output of the exploit on the screen for the first iteration. Why?
#		     2) Why do I need enqueue_output in different thread? ??"prevent blocking"??
    def launch_spl(self,lock):
        try:
            self.cycle_num += 1
            self.last_launch_time = time()

            need_launch_in_shell = (os.name == "nt")
            need_close_fd = (os.name != "nt")

            # launch sploit proccess with team_ip as arg
            spl = Popen([self.sploit_name, self.team_ip],
                            stdout=PIPE, stderr=STDOUT, bufsize=1,
                            shell=need_launch_in_shell, close_fds=need_close_fd) # !!!!!!!! close_fds why?
            q = queue.Queue()

            # we are processing output in other thread to prevent blocking
            def enqueue_output(queue, out):
                while True:
                    line = out.readline()
                    queue.put(line)
                    if not line:
                        break

            t = threading.Thread(target=enqueue_output, args=(q, spl.stdout))
            t.daemon = True
            t.start()

            # get output by lines until EOF
            while True:
                try:
                    remaining_time = MAX_RUNTIME - (time() - self.last_launch_time)
                    line = q.get(timeout=remaining_time)
                except (Empty, ValueError):
                    log("Killing %s sploit(tried to run for more than %d secs)" % (
                       self.team_name, MAX_RUNTIME))
                    break

                if not line:
                    break

                line = line.strip()
                if not line:
                    continue

                if self.cycle_num == 1:
                    print("%s: %s" % (self.team_name, line))

                flags = re.findall(FLAG_FORMAT, line)

                for flag in flags:
                    if flag not in self.flags:
                        if self.cycle_num == 1:
                            log("Flag from %s: %s" % (self.team_name, flag))
                            with open(self.flag_filename, "ab", 0) as f:
                                f.write(flag + b"\n")

                        lock.acquire()
                        self.flags.add(flag)
                        lock.release()
                    else:
                        if self.cycle_num == 1:
                            log("Flag from %s: %s (dup)" % (self.team_name, flag))

        except Exception as E:
            log("Exception, team %s: %s" % (self.team_name, E) + "\a")
        finally:
            if self.cycle_num == 1:
                log("Sploit for team %s: hiding output" % self.team_name)

def one_launch():
    while True:
        owner = owners_queue.get()

        if owner is None:
            break

        owner.launch_spl(lock)
        owners_queue.task_done()

# LETS ROCK !!!
if len(sys.argv) < 2:
    print("Usage: start_sploit.py <sploit>")
    sys.exit(1)

sploit_name = abspath(sys.argv[1])
if not exists(sploit_name):
    print("Sploit doesn't exist: %s" % sploit_name)
    sys.exit(1)

# ensure that flag directory is exists
if not exists("flags"):
    os.makedirs("flags")

if os.name == "nt":
    # Because Windows sucks at the proccess management
    log("Windows detected. Timeouts are not supported on this os!")
    log("Please write only short-time-running exploits")
    MAX_RUNTIME = 0xFFFFFFFF # !!!!!!!!!! Why?

lock = threading.Lock()
owners = []
owners_queue = queue.Queue()
# generate_teams()
for team_name, team_ip in teams.items():
    owner = TeamOwner(sploit_name, team_name, team_ip)
    owners.append(owner)

workers = []
for w in range(multiprocessing.cpu_count()):
    w = threading.Thread(target=one_launch)
    w.daemon = True
    w.start()
    workers.append(w)


try:
    while True:
        # generate_teams()

        # generate stats in a loop
        lock.acquire()
         # We need to create a new object so we can later find new flags
         # comparing two different sets
        last_flags = [set(o.flags) for o in owners]
        last_stats = [(len(o.flags), o.cycle_num) for o in owners]
        lock.release()

        for o in owners:
            owners_queue.put(o)

        sleep(1)  # show stat at zero second
        owners_queue.join() # block until all sploits are done

        curr_flags = [o.flags for o in owners]
        curr_stats = [(len(o.flags), o.cycle_num) for o in owners]
        stats = [(owners[i].team_name, # stats[0] -- command name

                # stats[1] -- number of flags, stats[2] -- number of new flags
                curr_stats[i][0], curr_stats[i][0] - last_stats[i][0],
                # stats[3] -- number of cycles, stats[4] -- number of new cycles
                curr_stats[i][1], curr_stats[i][1] - last_stats[i][1],
                # stats[5] -- new flags
                list(curr_flags[i] - last_flags[i]))
                        for i in range(len(owners))]

        new_flags = ["%s: %s" % (s[0], s[5]) for s in stats]
        log("LAST MINUTE NEW FLAGS: " + "\n".join(new_flags))

        flag_stats = ["%s: %d(%d)" % (s[0], s[2], s[1]) for s in stats]
        log("LAST MINUTE FLAG STATS: " + ", ".join(flag_stats))

        iter_stats = ["%s: %d(%d)" % (s[0], s[4], s[3]) for s in stats]
        log("LAST MINUTE LAUNCHES STATS: " + ", ".join(iter_stats))

except KeyboardInterrupt:
    print("Ctrl-c received!")

log("Done")

# stop workers
for i in range(multiprocessing.cpu_count()):
    owners_queue.put(None)
for w in workers:
    w.join()
