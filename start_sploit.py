#!/usr/bin/env python
# author: Alexander Bersenev (Bay) from Hackerdom team
# starts one sploit for all teams

from flag_format import FLAG_FORMAT
from team_list   import TEAMS

from time        import sleep, strftime
from os.path     import basename, splitext, abspath, exists
from subprocess  import Popen, PIPE, STDOUT
import threading
import re
import sys
import os

TIMEOUT = 60  # sploit timeout in sec
MAX_ATTEMPTS = 40 # number of sploit fail attempts

def log(text):
    print("%s " % strftime("%H:%M:%S") + text)


def get_unfinished_teams():
    return [t.name for t in threading.enumerate() if t.daemon]


class TeamOwner(threading.Thread):
    def __init__(self, sploit_name, team_name, team_ip):
        threading.Thread.__init__(self, name=team_name)

        self.sploit_name = sploit_name
        self.team_name   = team_name
        self.team_ip     = team_ip

        spl_short_name = splitext(basename(sploit_name))[0]
        log_filename   = "flags/%s_%s.txt" % (spl_short_name, team_name)
        self.logfile   = open(log_filename, "ab", 0)

        self.existed_flags = set()

    def run(self):
        log("Lauching %s %s for %s" %
              (basename(self.sploit_name), self.team_ip, self.team_name))
        garbage=0
        try:
            while True:
                    need_launch_in_shell = (os.name == "nt")
                    # launch sploit proccess with team_ip as arg
                    spl = Popen([self.sploit_name, self.team_ip],
                                stdout=PIPE, stderr=STDOUT,
                                shell=need_launch_in_shell, bufsize=1)
                    # get output by lines until EOF
                    while True:
                        nextline = spl.stdout.readline()
                        if not nextline:
                            break
        
                        nextline = nextline.strip()
                        if not nextline:
                            continue
                        print("%s: %s" % (self.team_name, nextline))
        
                        flags = re.findall(FLAG_FORMAT, nextline)

                        if not flags:
                                garbage+=1
                        else:
                                garbage=0

                        for flag in flags:
                            log("Flag from %s: %s" % (self.team_name, flag))
                            if flag not in self.existed_flags:
                                self.logfile.write(flag + b"\n")
                                self.existed_flags.add(flag)
                    spl.communicate()  # wait for finish
                    sleep(10)
                    # if sploit can`t get flags from team - kill him.
                    if garbage > MAX_ATTEMPTS:
                        log("Max fail attempts is reached, team %s" % self.team_name + "\a")
                        break
        except Exception as E:
            log("Exception, team %s: %s" % (self.team_name, E) + "\a")

# LETS ROCK !!!
if len(sys.argv) < 2:
    print("Usage: start_sploit.py <sploit>")
    sys.exit(1)

sploit_name = abspath(sys.argv[1])
if not exists(sploit_name):
    print("Sploit doesn't exist: " + sploit_name)
    sys.exit(1)

for team_name, team_ip in TEAMS.items():
    owner = TeamOwner(sploit_name, team_name, team_ip)
    owner.daemon = True
    owner.start()  # start pwning thread for the team

# do small 1-sec sleeps till ctrl-c or till end of the work
try:
    for i in range(TIMEOUT):
        sleep(1)
        if not get_unfinished_teams():
            break

except KeyboardInterrupt:
    print("Ctrl-c received!")

if get_unfinished_teams():
    log("Done. Teams with timeouts: %s" % get_unfinished_teams())
else:
    log("Done.")
